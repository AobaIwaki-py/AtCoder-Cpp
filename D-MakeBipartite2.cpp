#include <bits/stdc++.h>
using namespace std;

// 手も足も出なかった

int N,M;
int u[200010];
int v[200010];
int cnt = 0;

int main()
{
    cin >> N >> M;
    for(int i = 0; i < M; i++) cin >> u[i] >> v[i];

    vector G(N+1, vector<int>(N+1,0));

    for(int i = 0; i < M; i++){
        for(int j = 0; j < M; j++){
            G[u[i]][v[i]] = 1;
            G[v[i]][v[i]] = 1;
        }
    }
    for(int i = 1; i <= N; i++){
        for(int j = 1+i; j <= N; j++){
            if(G[i][j] == 0){
                G[i][j] = 1;

                vector<int> color(N+1, -1);   // color[v]：頂点 v の色が黒なら 1, 白なら 0, 未探索なら -1
                bool ans = 1;

                // 全ての頂点について
                for(int v = 0; v < N; ++v) {
                    // 頂点 v がすでに訪問済みであれば、スキップ
                    if(color[v] != -1) {continue;}

                    // そうでなければ、頂点 v を含む連結成分は未探索
                    // 頂点 v の色を白で決め打ちしたうえで、幅優先探索を行う

                    queue<int> que; // 探索候補の頂点番号を入れるキュー
                    color[v] = 0;
                    que.push(v);

                    // キューに要素が残っている限り
                    while(que.size() > 0) {
                        int qv = que.front();
                        que.pop();

                        // 頂点 qv に隣接している頂点 nv について、
                        for(int i = qv+1; i < N; i++){
                            if(G[qv][i] == 1){
                                if(color[i] != -1){
                                    if(color[i] == color[qv]) ans = 0;
                                    continue;
                                }
                            }
                            color[i] = 1 - color[qv];
                            que.push(i);
                        }
                        // for(auto nv : G[qv]) {
                        //     // nv がすでに探索済みならば、スキップする
                        //     if(color[nv] != -1) {
                        //         // 隣り合う頂点どうしが同じ色なら、答えは No
                        //         if(color[nv] == color[qv]) {ans = 0;}
                        //         continue;
                        //     }
                        //     // そうでなければ、頂点 nv の色を color[qv] と逆にしたうえで、nv も探索候補に入れる
                        //     color[nv] = 1 - color[qv];
                        //     que.push(nv);
                        // }
                    }
                }
                G[i][j] = 0;
                if(ans) cnt++;
            }
        }
    }
    cout << cnt/2 << endl;
    return 0;
}

// 模範解答
// 解答の方針：
// まず、与えられたグラフが連結であるかどうかを考える。
// 連結である場合：深さ優先探索などを用いて二部グラフであるかどうかの判定を行う。
// この時、二部グラフでなければ、それに辺を一本追加して得られるグラフのまた二部グラフでないので答えは、0となる。
// 二部グラフであった場合、辺で結んでも二部グラフであり続けるような頂点のペアは、異なる色で塗られた頂点のペアである。
// 従って、頂点のペアの個数N(N-1)/2から、同じ色で塗られたペアの個数と、初めから辺で結ばれている頂点のペアの個数Mを引いたものが答えとなる。
// ここで、N(N-1)/2は、完全グラフの辺の本数を表しており、そこから同じ色のペアを除く。すると、完全二部グラフの辺の本数が現れる。
// そこからさらに、現在接続されている頂点のペアの個数を除くと答えの値が得られる。
// 次に、グラフが連結でない場合を考える。まず、それぞれの連結成分について二部グラフであるか判定を行う。
// ここで、一つでも二部グラフでなければG全体も二部グラフでないので、答えは0となる。
// 従って、すべての連結成分が二部グラフである場合を考える。
// 同じ連結成分に属する頂点のペアについては、Gが連結な場合と同様にもとまる。
// 一方、異なる連結成分に属する頂点同士のペアについては、その間にへんを追加して得られるグラフは必ず二部グラフとなる。
// 以上より、辺を結ぶことで二部グラフでなくなってしまうような頂点のペアとは即ち、同じ連結成分に属する同じ色の頂点同士のペアである。
// 以上をまとめると、本問題の答えは、頂点のペアの個数N(N-1)/2から各連結成分の同じ色に塗られた頂点同士のペアの個数を引き、
// さらに初めから辺で結ばれている頂点のペアの個数Mを引いたものである。
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> P;

ll n,m;
vector<int> G[200005];
int color[200005];

// 深さ優先探索を行い、ペア型の変数を返す
// 二部グラフかどうかの判定と、探索頂点vからふかさ優先探索を行った場合の
// 二部グラフにおける同じ色の頂点の個数をそれぞれres.first, res.secondとして返す。
P dfs(int v, int p, int c){
    // ペア型の変数retを初期化する
    P ret = P(0,0);
    // 頂点vを探索したことを示すためにフラグを立てる。
    color[v] = c;

    // c = 1, -1で色の違いを表現する。
    // それぞれの色を探索するごとに値をインクリメントする。
    // これは、同じ色の頂点数を表す。
    if(c == 1) ret.first++;
    else ret.second++;

    // autoを用いて、G[v]に格納されている値を順番に呼び出している。
    // 要するに、vに隣接する頂点を順番に呼び出している。
    for(auto u : G[v]){
        // u==p 即ち、自分自身の場合はスキップする。
        // u番目の頂点の色が今塗っている色と逆、すなわちcolor[u]=-cであれば処理を続行する。
        if( u == p || color[u] == -c) continue;
        // 隣接した頂点と同じ色なので、二部グラフでないという結果を返す。
        if(color[u] == c) return P(-1, -1);
        // 再帰的に関数を呼び出す。
        // uに関して、探索を行う。この時に塗る色は、-cとする。
        // 自分の先の頂点における頂点の色の個数をresで受け取る。
        P res = dfs(u, v, -c);
        // 自分の先の頂点において、二部グラフでないことが判明した場合、二部グラフでないという結果を返す。
        if(res.first == -1) return P(-1, -1);
        // 一つ先の頂点における同じ色の頂点数resを自分自身が持っている情報retに足し合わせる。
        ret.first += res.first, ret.second += res.second;
    }
    // 自分が探索した場所までにおける同じ色の頂点数を返す。
    return ret;
}

int main()
{
    cin >> n >> m;
    int u, v;
    // 隣接行列を作成する
    for(int i = 1; i <= m; i++){
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }

    // 完全グラフの辺の本数N(N-1)/2から初めからつながっている辺の本数Mを引く
    ll ans = n*(n-1)/2 - m;
    for(int i = 0; i <= n; i++){
        // 探索ずみであればcolor[i]=1,-1となっている。
        // 何らかの値が入っていれば、color[i]は、true, 何も入っていなければfalseを返すので
        // それを判定する。
        if(!color[i]){
            // 深さ優先探索を行い、結果をresに格納する。
            // res.firstは、c=1の頂点数を格納する。
            // res.secondは、c=-1の頂点数を格納する。
            P res = dfs(i, -1, 1);
            // 二部グラフでなければ0を出力する。
            if(res.first == -1){
                cout << 0 << endl;
                return 0;
            }
            // 同じ色に塗られた頂点同士のペアをひく
            ans -= res.first * (res.first - 1) / 2;

            // 同じ色に塗られた頂点同士のペアをひく
            ans -= res.second * (res.second - 1) / 2;

        }
    }
    cout << ans << endl;

    return 0;
}